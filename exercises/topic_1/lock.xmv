MODULE Boat
  VAR
    state : {outUp, inside, outDown};
  ASSIGN
    init(state) := outUp;


MODULE Door
  VAR
    state : {open, closed};
    lastOpened : boolean;
  ASSIGN
    next(state) :=
      case
          state = closed & lastOpened = TRUE : closed;
          state = closed & lastOpened = FALSE : open;
          state = open : closed;
        esac;

    next(lastOpened) :=
      case
          state = open : TRUE;
          state = closed : lastOpened;
        esac;

MODULE main
  VAR
    doorUp : Door();
    doorDown : Door();
    doorState : {open, closed};
    boatState : {outUp, inside, outDown};
    b1 : Boat();
    b2 : Boat();
    b3 : Boat();

  DEFINE
    boats_inside :=
    (case
         b1.state = inside : 1;
         TRUE : 0;
       esac) +
    (case
         b2.state = inside : 1;
         TRUE : 0;
       esac) +
    (case
         b3.state = inside : 1;
         TRUE : 0;
       esac);

    capacity := 2 - boats_inside;

    b1_queued := (b1.state = outUp & doorUp.state = open) | (b1.state = outDown & doorDown.state = open);
    b2_queued := (b2.state = outUp & doorUp.state = open) | (b2.state = outDown & doorDown.state = open);
    b3_queued := (b3.state = outUp & doorUp.state = open) | (b3.state = outDown & doorDown.state = open);

    -- priority entry first e1 then e2 then e3
    e1 := b1_queued & (capacity > 0);
    e2 := b2_queued & (capacity - (case e1 : 1; TRUE : 0; esac) > 0);
    e3 := b3_queued & (capacity - (case e1 : 1; TRUE : 0; esac) - (case e2 : 1; TRUE : 0; esac) > 0);

  ASSIGN
    init(doorDown.state) := closed;
    init(doorDown.lastOpened) := FALSE;
    init(doorUp.state) := open;
    init(doorUp.lastOpened) := TRUE;

    -- Enter only if they have priority
    next(b1.state) :=
      case
          e1 : inside;

          b1.state = inside & doorUp.state = open & doorUp.lastOpened = FALSE : outUp;
          b1.state = inside & doorDown.state = open & doorDown.lastOpened = FALSE : outDown;

          TRUE : b1.state;
        esac;

    next(b2.state) :=
      case
          e2 : inside;

          b2.state = inside & doorUp.state = open & doorUp.lastOpened = FALSE : outUp;
          b2.state = inside & doorDown.state = open & doorDown.lastOpened = FALSE : outDown;

          TRUE : b2.state;
        esac;

    next(b3.state) :=
      case
          e3 : inside;

          b3.state = inside & doorUp.state = open & doorUp.lastOpened = FALSE : outUp;
          b3.state = inside & doorDown.state = open & doorDown.lastOpened = FALSE : outDown;

          TRUE : b3.state;
        esac;

  -- never open both doors in the next step
  TRANS !(next(doorUp.state) = open & next(doorDown.state) = open)

  -- A door must only open if a boat is waiting outside of it.
  TRANS doorUp.state = open -> (b1.state = outUp | b2.state = outUp | b3.state = outUp | capacity < 2)
  TRANS doorDown.state = open -> (b1.state = outDown | b2.state = outDown | b3.state = outDown | capacity < 2)

  -- The capacity must range from 0 to 2
  INVAR capacity >= 0 & capacity <= 2
